#!/usr/bin/env ruby

require 'optparse'
require 'rubygems'
require 'beaver'

options, matchers = {}, {}
o = OptionParser.new do |opts|
  opts.banner = 'Usage: beaver [options] [dsl.rb...] [/rails/production.log...]'
  opts.on('--path PATH', 'URL path, string or regex') { |path| matchers[:path] = Regexp.new(path, Regexp::IGNORECASE) }
  opts.on('--method METHOD', 'HTTP request method(s), e.g. get or post,put') { |methods| matchers[:method] = methods.split(',').map { |m| m.downcase.to_sym } }
  opts.on('--controller CONTROLLER', 'Rails controller name or regex') { |c| matchers[:controller] = Regexp.new(c, Regexp::IGNORECASE) }
  opts.on('--action CONTROLLER', 'Rails action name or regex') { |a| matchers[:action] = Regexp.new(a, Regexp::IGNORECASE) }
  opts.on('--status STATUS', 'HTTP status(es), e.g. 200 or 500..503') { |s| matchers[:status] = s =~ /(\.+)/ ? Range.new(*s.split($1).map(&:to_i)) : s.to_i }
  opts.on('--ip IP', 'IP address, string or regex') { |ip| matchers[:ip] = Regexp.new(ip) }
  opts.on('--tagged TAGS', 'Comma-separated Rails Tagged Logger tags') { |tags| (matchers[:tagged] ||= []) << tags }
  opts.on('--params PARAMS', 'Request parameters string (a Ruby Hash), string or regex') { |params| matchers[:params_str] = Regexp.new(params, Regexp::IGNORECASE) }
  opts.on('--format FORMAT', 'Response format(s), e.g. html or json,xml') { |f| matchers[:format] = f.split(',').map(&:to_sym) }
  opts.on('--longer-than MS', 'Minimum response time in ms') { |ms| matchers[:longer_than] = ms.to_i }
  opts.on('--shorter-than MS', 'Maximum response time in ms') { |ms| matchers[:shorter_than] = ms.to_i }
  opts.on('--on DATE', 'Only include log entries from the given date (yyyy-mm-dd or -n days)') { |d| matchers[:on] = Beaver::Utils.parse_date(d) }
  opts.on('--after DATE', 'Only include log entries from after the given date (yyyy-mm-dd or -n days)') { |d| matchers[:after] = Beaver::Utils.parse_date(d) }
  opts.on('--before DATE', 'Only include log entries from before the given date (yyyy-mm-dd or -n days)') { |d| matchers[:before] = Beaver::Utils.parse_date(d) }
  opts.on('--today', 'Alias to --on=-0') { matchers[:on] = Date.today }
  opts.on('--yesterday', 'Alias to --on=-1') { matchers[:on] = Date.today-1 }
  opts.on('--regex REGEX', 'A regex string to be matched against the entire request') { |r| matchers[:match] = Regexp.new(r, Regexp::IGNORECASE) }
  opts.on('--print FORMAT', 'Formatted request string, e.g. "%{ip} went to %{path} passing %{params[:email]}"') { |hit| options[:print] = hit }
  opts.on('--tablize', 'Print the formatted string in a table') { options[:tablize] = true }
  opts.on('--stdin', 'Read log content from stdin (for typing/pasting)') { options[:tty] = true }
  opts.on('-v', '--version', 'Show version') { puts "beaver #{Beaver::VERSION}"; exit }
end
o.parse!

# Separate the beaver files and log files, then build the Beaver arguments
beaver_files, log_files = ARGV.uniq.partition { |a| a =~ /\.rb$/ }
args = beaver_files.any? ? log_files << matchers : log_files

# Run Beaver
Beaver.stream *args do
  stdin!
  tty! if options[:tty]
  # Filter the logs through the DSL files
  if beaver_files.any?
    beaver_files.map! { |b| File.open(b, &:read) }
    beaver_files.each { |b| eval b }
  # Filter the logs through the CLI options
  else
    # Format each entry
    if options[:print]
      hit :cli, matchers
      dam :cli do
        options[:print].gsub!(/%\{/, '#{')
        arg_pattern = /#\{[^\}]+\}/
        # Map each hit to an array of values
        lines = hits.map do |hit|
          options[:print].gsub(arg_pattern).map { |match| hit.instance_eval(%Q|"#{match}"|) rescue '?' }
        end
        # Make each column the same length
        if options[:tablize]
          max_sizes = lines.inject([0]*lines.first.size) do |sizes, vals|
            vals.each_with_index { |val, i| sizes[i] = val.size if val.size > sizes[i] }; sizes
          end
          lines.map! { |vals| vals.each_with_index.map { |val, i| val.ljust(max_sizes[i]) } }
        end
        # Print each formatted line
        text = options[:print].split arg_pattern
        lines.each { |vals| puts text.map { |t| "#{t}#{vals.shift}" }.join }
      end
    # Print the entirety of each entry
    else
      hit :cli, matchers do puts to_s << $/ end
    end
  end
end
